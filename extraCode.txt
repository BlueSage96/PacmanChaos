//pacman class
  draw(){
        fill(this.color);
        let theta = PI / 3 * sq(sin(this.thetaOff));//chomping

        if(this.speedY < 0){
            arc(px,py,this.r,this.r, -theta - PI/6, theta + 7 * PI/6);
        }
        else if(this.speedY > 0){
            arc(px,py,this.r,this.r, -7 * PI/6 - theta, theta + PI/6);
        }
        else if(this.speedX < 0){
            arc(px, py, this.r,this.r,theta + PI, -theta + PI);
        }
        else if(this.speedX > 0){
            arc(px, py, this.r,this.r,theta, -theta);
        }

        else{
            //up
            if(this.dir == 0){
                arc(px,py,this.r,this.r,-theta - PI/6, theta + 7 * PI/6);
            }
            //down
            else if(this.dir == 1){
                arc(px,py,this.r,this.r,-7 * PI/6 - theta, theta + PI/6);
            }
            //left
            else if(this.dir == 2){
                arc(px,py,this.r,this.r,theta + PI, -theta + PI);
            }
            //right
            else if(this.dir == 3){
                arc(px,py,this.r,this.r,theta,-theta);
            }
            else{
                arc(px,py,this.r,this.r,theta,-theta);//something wrong here w/ direction of mouth
                //eyes
                fill(0);
                ellipse(px + 10, py - 10,10,10);
            }
        }


       
        this.thetaOff += 0.15;//mouth movement
        console.log(theta);
    }

    move(){
        px += vx;
        py += vy;
        vx = 0;
        vy = 0;

        if(keyIsDown(UP_ARROW)){
            vx = 0;
            vy = -vel * this.speedY;
            this.dir = 0;
        }

        if(keyIsDown(DOWN_ARROW)){
            vx = 0;
            vy = vel * this.speedY;
            this.dir = 1;
        }

        if(keyIsDown(LEFT_ARROW)){
            vx = -vel * this.speedX;
            vy = 0;
            this.dir = 2;
        }

        if(keyIsDown(RIGHT_ARROW)){
            vx = vel * this.speedX;
            vy = 0;
            this.dir = 3;
        }
    }

//may cause issues later
// transform a cell's index into on-screen coordinates
// function positionX(px){
//     return (int)(((px - marginHori) / size) + 0.5);
// }

// // transform a cell's index into on-screen coordinates
// function positionY(py){
//   return (int)(((py - marginVert) / size) + 0.5);
// }

// function pacmanControls(){
//      px += vx;
//      py += vy;
//      vx = 0;
//      vy = 0;

//     //right
//     if(keyIsDown(RIGHT_ARROW)){
//       vx = vel * speed;
//        vy = 0;
//     }

//     //left
//     if(keyIsDown(LEFT_ARROW)){
//         vx = -vel * speed;
//        vy = 0;
//     }


//     //up
//     if(keyIsDown(UP_ARROW)){
//        vx = 0;
//        vy = -vel * speed;
//     }
    
//     //down
//     if(keyIsDown(DOWN_ARROW)){
//         vx = 0;
//         vy = vel * speed;
//     }
   
// }

// function pacmanDraw(){
//     fill(pacmanCol);
//    // translate(px, py);
//     ellipse(px,py,pacSize,pacSize);
// }

//    switch(keyCode){
//        case RIGHT:
//         for(let i = 1; i < row + 1; i++){
//             if(py == centerY(i) && turnRight()){
//                 vx = vel;
//                 vy = 0;
//                 direction = "right";
//             }
//         }
//         break;
//         case LEFT:
//             for(let i = 1; i < row + 1; i++){
//                 if(py == centerY(i) && turnLeft()){
//                     vx = -vel;
//                     vy = 0;
//                     direction = "left";
//                 }
//             }
//             break;

            // case UP:
            //   for(let i = 1; i < col + 1; i++){
            //     if(px == centerX(i) && turnUp()){
            //         vx = 0;
            //         vy = vel;
            //         direction = "up";
            //     }
            // }
            // break;
            // case DOWN:
            //    for(let i = 1; i < col + 1; i++){
            //         if(px == centerX(i) && turnDown()){
            //             vx = 0;
            //             vy = -vel;
            //             direction == "down";
            //         }
            //     }
            // break;
    // }


let my,shared,pacmanFont;
let marginVert,marginHori,col,row;
let obstacles, borders;
let scene = 0;
let size = 50;
let spacing = 2;
function preload(){
    // partyConnect(
    //     "wss://deepstream-server-1.herokuapp.com",
    //     "Pacman_basic",
    //     "main1"
    //   );
    //   shared = partyLoadShared("globals");
    //   my = partyLoadMyShared();
    //   participants = partyLoadParticipantShareds();

      //sounds


     //sprites

     //Font
    //  pacmanFont = loadFont("assets/crackman.TTF");
}

function setup(){
    var mainCanvas = createCanvas(1400,1000);
    mainCanvas.parent("canvasdiv");
    let frameCount = frameRate(60);
    //textFont(pacmanFont);
    marginVert = (width - col * size) / 2;
    marginHori = (height - row * size) / 2;
    obstacles = color(50,0,200);
    borders = color(255,0,0);

    //toggle server info
    // partyToggleInfo(false);
    // toggle = document.getElementById('toggle');

    // if(partyIsHost()){
    //     partySetShared(shared,{
    //         player: 1,
    //         hostStart: false,
    //         hostRestart: false,
    //         role: "Observer"
    //     });
    // }

    //Make a select menu
    // teamDropDownMenu = createSelect();
    // teamDropDownMenu.option("Pacman");
    // teamDropDownMenu.option("Blue Ghost");
    // teamDropDownMenu.option("Red Ghost");
    // teamDropDownMenu.option("Pink Ghost");
    // teamDropDownMenu.option("Orange Ghost");
    // teamDropDownMenu.position(40,800);
    // teamDropDownMenu.id("menu");

    // teamDropDownMenu.changed(() =>{
    //     my.selectedTeam = teamDropDownMenu.value();
    // });
}

function draw(){
   background(1);
       //boundaries
       fill(0,0,255);
       stroke(borders);
       strokeWeight(spacing);
       rect(marginHori,marginVert,width - 2 * marginHori, height - 2 * marginVert);
       fill(0,0,255);
       noStroke();
   
       //exits
       //left side
       rect(9, centerY(6) - 25, 25, 50);
       stroke(borders);
       line(centerX(0),centerY(6) - 25, centerX(1) - 25, centerY(6) - 25);
       line(centerX(0), centerY(6) + 25, centerX(1) - 25, centerY(6) + 25);
   
       //right
       noStroke();
       rect(centerX(col) + 10, centerY(6) - 25, 25, 50);
       stroke(borders);
       line(centerX(col) + 25, centerY(6) + 25, centerX(col + 1), centerY(6) + 25);
       line(centerX(col) + 25, centerY(6) - 25, centerX(col + 1), centerY(6) - 25);
   
      // Draw obstacles of the type: (column, row, width XX, length YY)
       walls(2, 2, 1, 2);
       walls(2, 5, 2, 1);
       walls(2, 7, 1, 3);
       walls(3, 7, 1, 1);
       walls(4, 2, 1, 3);
       walls(4, 9, 2, 1);
       walls(5, 6, 2, 1);
       walls(5, 7, 1, 1);
       walls(4, 2, 1, 3);
       walls(7, 8, 2, 2);
       walls(6, 4, 4, 1);
       walls(6, 2, 1, 1);
       walls(8, 2, 1, 2);
       walls(13, 2, 1, 2);
       walls(11, 2, 1, 3);
       walls(10, 2, 1, 1);
       walls(12, 5, 2, 1);
       walls(13, 7, 1, 3);
       walls(12, 7, 1, 1);
       walls(8, 6, 3, 1);
       walls(10, 8, 1, 2);
       walls(11, 9, 1, 1);
//    switch(scene){
//        case 1:
//         game();
//         break;
//        default:
//         startScreen();
//         break;
//    }
}

function mousePressed(){
    if(scene == 0){
        scene = 1;
    }
}

function startScreen(){
    textSize(60);
    fill(255);
    if(frameCount % 60 < 30){
        text("Start Game",500,750);
    }
}

function waitForHost(){

}

function game(){
    
   // background(0,255,0);
//    text("Draw maze",500,500);
//     maze();

    // pacmanControls();
    // ghostControls();
    // chaosMode();
}

function gameOver(){

}

function maze(){

}

function walls(x,y,numC,numR){
    let x0, y0, large, comp;
    x0 = marginHori + (x - 1) * size;
    y0 = marginVert + (y - 1) * size;
    large = numC * size;
    comp = numR * size;
    fill(50,0,200);
    noStroke();
    strokeWeight(spacing / 2);
    rect(x0,y0,large,comp);
}

function pause(){

}

function death(){

}

function victory(){

}

function pacmanControls(){

}

function ghostControls(){

}

function centerX(col){
    return marginHori + (col - 0.5) * size;
}

function centerY(nLin){
    return marginVert + (nLin - 0.5) * size;
}

function chaosMode(){

}


css

@media only screen and (max-width: 2260px){
     /*index.html*/
  
    /* div.flexbox{
        width: 80vw;
        height: 80vh;
        padding-bottom: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
    } */

    #canvasdiv{
        border: 2px solid white;
        position: absolute;
        top: 2vh;
        left: 19.5vw;
    }

    button{
        font-family: pacmanFont;
        font-size: 45px;
        background-color: black;
        color: white;
        padding: 0;
    }

    #toggle{
        position: absolute;
        top: 25vh;
        left: 0.6vw;
        padding: 20px;
    }

    #kit{
    position: absolute;
    top: 45vh;
    left: 3vw;
    padding: 5px 0;
    }

    #instructionsButton{
        position: absolute;
        top: 45vh;
        left: 80vw;
        padding: 3px 0;
    }

    #instructionsButton a, #back a, #original a, #kit a{
        color: white;
        text-decoration: none;
        padding: 20px;
    }

    #instructionsButton a:hover, #back a:hover, #original a:hover, #toggle:hover, #kit a:hover{
        color: yellow;
        background-color: gray;
    }

    #back{
    margin-left: 50px;
    padding: 5px 0;
    }

    #original{
        position: absolute;
        top: 25vh;
        left: 86vw;
        padding: 5px 0;
    }

    select#menu{
        color: white;
        padding: 20px;
        top: 45vh;
        left: 100vw;
    }
    /*instructions.html*/
    #infoBox{
        font-size: 30px;
        border: 2px solid white;
        position: absolute;
        top: 18vh;
        left: 25vw;
        color: white;
        background-color: black;
    }
}

maze attempt
  //top left
            // walls(2, 2, 2, 1),
            // walls(4, 2, 1, 2),
            // //bottom left - S
            // walls(2, 5, 4, 1),
            // walls(2, 6, 1, 2),
            // walls(2, 7, 4, 1),
            // walls(5, 7, 1, 2),
            // walls(2, 9, 4, 1),
           
            // //top right cross
            // walls(9, 2, 1, 3),
            // walls(8, 3, 3, 1),
            // //bottom right
            // walls(11,11,3,1),
            // walls(13,9,1,3),
       
            // //T
            // walls(7, 8, 4, 1),
            // walls(8, 9, 1, 2),
            // //walls(6, 4, 4, 1),

            // //top
            // walls(7, 2, 4, 1)